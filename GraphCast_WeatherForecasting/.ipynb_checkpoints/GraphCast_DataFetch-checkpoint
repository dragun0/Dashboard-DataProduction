{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "69cb64ff-70e5-48a6-ba73-384f89336710",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Used to fetch the graphcast predictions from the aws bucket and store subsets of the desired variables to new files"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e1a168b1-486f-47ef-8047-23a63644182d",
   "metadata": {},
   "outputs": [],
   "source": [
    "import boto3\n",
    "import os\n",
    "from netCDF4 import Dataset\n",
    "import cfgrib\n",
    "import xarray as xr"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "50ba177f-2129-4362-911f-17c10473500e",
   "metadata": {},
   "outputs": [],
   "source": [
    "def list_folders(bucket_name):\n",
    "    \"\"\"Lists unique folder prefixes in the S3 bucket.\"\"\"\n",
    "    response = s3_client.list_objects_v2(Bucket=bucket_name, Delimiter='/')\n",
    "    return [prefix['Prefix'] for prefix in response.get('CommonPrefixes', [])]\n",
    "    \n",
    "def list_files(bucket_name, prefix):\n",
    "    \"\"\"Lists all files in a specific folder (prefix)\"\"\"\n",
    "    response = s3_client.list_objects_v2(Bucket=bucket_name, Prefix=prefix)\n",
    "    return [file['Key'] for file in response.get('Contents', [])]\n",
    "\n",
    "def download_file(bucket_name, file_key):\n",
    "    \"\"\"Downloads a file to the local machine\"\"\"\n",
    "    filename = os.path.basename(file_key)  # Extract filename from S3 key\n",
    "    print(f\"Downloading {file_key} -> {filename}\")\n",
    "    s3_client.download_file(bucket_name, file_key, filename)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3128b800-fcd5-4870-92b9-9109f3dc325b",
   "metadata": {},
   "outputs": [],
   "source": [
    "AWS_ACCESS_KEY_ID = '' # @param {type:\"string\"}\n",
    "AWS_SECRET_ACCESS_KEY = ''\n",
    "AWS_BUCKET_NAME = \"\"\n",
    "\n",
    "GC_FILENAME = \"2024030106-output\"\n",
    "GC_TIME = \"2024-03-01T06:00:00\"\n",
    "TARGET_MONTH = \"20240301\"\n",
    "\n",
    "# Initialize S3 Client with credentials\n",
    "s3_client = boto3.client(\n",
    "    's3',\n",
    "    aws_access_key_id=AWS_ACCESS_KEY_ID,\n",
    "    aws_secret_access_key=AWS_SECRET_ACCESS_KEY\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "49707353-286a-4cc7-b1a7-83fb3ed9a537",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Download computed GC forecasts from aws bucket"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "44298c0d-9d11-4ae6-bc30-826566b7eeb2",
   "metadata": {},
   "outputs": [],
   "source": [
    "def main():\n",
    "    print(f\"Searching for '{GC_FILENAME}' in {AWS_BUCKET_NAME}\")\n",
    "\n",
    "    # Step 1: Get all folders (prefixes)\n",
    "    folders = list_folders(AWS_BUCKET_NAME)\n",
    "    \n",
    "    if not folders:\n",
    "        print(\"No folders found in the bucket.\")\n",
    "        return\n",
    "\n",
    "    # Step 2: Iterate through each folder\n",
    "    found = False\n",
    "\n",
    "    for folder in folders:\n",
    "        print(f\"Checking folder: {folder}\")\n",
    "    \n",
    "        files = list_files(AWS_BUCKET_NAME, folder)\n",
    "    \n",
    "        for file_key in files:\n",
    "            if file_key.endswith(GC_FILENAME):\n",
    "                print(f\"✅ Found target file in {folder}, downloading...\")\n",
    "                download_file(AWS_BUCKET_NAME, file_key)\n",
    "                found = True\n",
    "                break  # Stop checking more files\n",
    "    \n",
    "        if found:\n",
    "            break  # Stop checking more folders\n",
    "    \n",
    "    if not found:\n",
    "        print(f\"❌ Target file '{GC_FILENAME}' not found in any folder.\")\n",
    "        return\n",
    "\n",
    "    # Extract the needed variables from the GC output file\n",
    "\n",
    "    datasets = cfgrib.open_datasets(GC_FILENAME)\n",
    "    \n",
    "    # u10 and v10 are in dataset 1\n",
    "    ds_u10 = datasets[0][[\"u10\"]]\n",
    "    ds_v10 = datasets[0][[\"v10\"]]\n",
    "    # t2m is in dataset 2\n",
    "    ds_t2m = datasets[1][[\"t2m\"]]\n",
    "    # msl is in dataset 4\n",
    "    ds_msl = datasets[3][[\"msl\"]]\n",
    "\n",
    "    # tp is in dataset 6\n",
    "    ds_tp = datasets[5][[\"tp\"]]\n",
    "    # filter the time coordinate\n",
    "    ds_tp = ds_tp.sel(time=GC_TIME)\n",
    "\n",
    "    # specific humidity (q) is in dataset 3. Filter for pressure level 1000 hPa\n",
    "    ds_q = datasets[2].sel(isobaricInhPa=1000)[[\"q\"]]\n",
    "\n",
    "    print(\"Accessed different variables\")\n",
    "\n",
    "    # Drop the heightAboveGround coordinate from datasets where it exists so the different values (10 and 2) won't cause a merging error\n",
    "    ds_u10 = ds_u10.drop_vars(\"heightAboveGround\", errors=\"ignore\")\n",
    "    ds_v10 = ds_v10.drop_vars(\"heightAboveGround\", errors=\"ignore\")\n",
    "    ds_t2m = ds_t2m.drop_vars(\"heightAboveGround\", errors=\"ignore\")\n",
    "    ds_msl = ds_msl.drop_vars(\"heightAboveGround\", errors=\"ignore\")\n",
    "    ds_tp = ds_tp.drop_vars(\"heightAboveGround\", errors=\"ignore\")\n",
    "\n",
    "    # Merge all the selected variables\n",
    "    merged_ds = xr.merge([ds_u10, ds_v10, ds_t2m, ds_msl, ds_tp])\n",
    "\n",
    "    print(\"Merged variables\")\n",
    "\n",
    "    # Save as NetCDF file\n",
    "    merged_ds.to_netcdf(f\"Surface Variables/{TARGET_MONTH}/{TARGET_MONTH}_gc_sv.nc\")\n",
    "    print(f\"Saved {TARGET_MONTH}_gc_sv.nc\")\n",
    "    \n",
    "    ds_q.to_netcdf(f\"Pressure Variables/{TARGET_MONTH}/{TARGET_MONTH}_gc_q.nc\")\n",
    "    print(f\"Saved {TARGET_MONTH}_gc_q.nc\")\n",
    "\n",
    "\n",
    "    # Delete the original file\n",
    "    os.remove(GC_FILENAME)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.2"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
